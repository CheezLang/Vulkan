use import vulkan
use import glfw

use import std.array
use import std.map
use import std.string
use import std.rc
use import std.math

mem :: import std.mem.allocator
io :: import std.io
fmt :: import std.fmt
fs :: import std.io.fs

use import spirv_cross

#export_scope

// bit flags
EventCreateFlags                                     :: VkEventCreateFlagBits
QueryPoolCreateFlags                                 :: VkQueryPoolCreateFlagBits
BufferViewCreateFlags                                :: VkBufferViewCreateFlagBits
PipelineVertexInputStateCreateFlags                  :: VkPipelineVertexInputStateCreateFlagBits
PipelineInputAssemblyStateCreateFlags                :: VkPipelineInputAssemblyStateCreateFlagBits
PipelineTessellationStateCreateFlags                 :: VkPipelineTessellationStateCreateFlagBits
PipelineViewportStateCreateFlags                     :: VkPipelineViewportStateCreateFlagBits
PipelineRasterizationStateCreateFlags                :: VkPipelineRasterizationStateCreateFlagBits
PipelineMultisampleStateCreateFlags                  :: VkPipelineMultisampleStateCreateFlagBits
PipelineDepthStencilStateCreateFlags                 :: VkPipelineDepthStencilStateCreateFlagBits
PipelineColorBlendStateCreateFlags                   :: VkPipelineColorBlendStateCreateFlagBits
PipelineDynamicStateCreateFlags                      :: VkPipelineDynamicStateCreateFlagBits
PipelineLayoutCreateFlags                            :: VkPipelineLayoutCreateFlagBits
DescriptorPoolResetFlags                             :: VkDescriptorPoolResetFlagBits
CommandPoolTrimFlags                                 :: VkCommandPoolTrimFlagBits
DescriptorUpdateTemplateCreateFlags                  :: VkDescriptorUpdateTemplateCreateFlagBits
DisplayModeCreateFlagsKHR                            :: VkDisplayModeCreateFlagBitsKHR
DisplaySurfaceCreateFlagsKHR                         :: VkDisplaySurfaceCreateFlagBitsKHR
InstanceCreateFlags                                  :: VkInstanceCreateFlagBits
DeviceCreateFlags                                    :: VkDeviceCreateFlagBits
MemoryMapFlags                                       :: VkMemoryMapFlagBits
SemaphoreCreateFlags                                 :: VkSemaphoreCreateFlagBits
DebugReportFlagsExt                                  :: VkDebugReportFlagBitsExt
PipelineRasterizationStateStreamCreateFlagsEXT       :: VkPipelineRasterizationStateStreamCreateFlagBitsEXT
PipelineViewportSwizzleStateCreateFlagsNV            :: VkPipelineViewportSwizzleStateCreateFlagBitsNV
PipelineDiscardRectangleStateCreateFlagsEXT          :: VkPipelineDiscardRectangleStateCreateFlagBitsEXT
PipelineRasterizationConservativeStateCreateFlagsEXT :: VkPipelineRasterizationConservativeStateCreateFlagBitsEXT
PipelineRasterizationDepthClipStateCreateFlagsEXT    :: VkPipelineRasterizationDepthClipStateCreateFlagBitsEXT
DebugUtilsMessengerCallbackDataFlagsEXT              :: VkDebugUtilsMessengerCallbackDataFlagBitsEXT
DebugUtilsMessengerCreateFlagsEXT                    :: VkDebugUtilsMessengerCreateFlagBitsEXT
PipelineCoverageToColorStateCreateFlagsNV            :: VkPipelineCoverageToColorStateCreateFlagBitsNV
PipelineCoverageModulationStateCreateFlagsNV         :: VkPipelineCoverageModulationStateCreateFlagBitsNV
ValidationCacheCreateFlagsEXT                        :: VkValidationCacheCreateFlagBitsEXT
PipelineCoverageReductionStateCreateFlagsNV          :: VkPipelineCoverageReductionStateCreateFlagBitsNV
HeadlessSurfaceCreateFlagsEXT                        :: VkHeadlessSurfaceCreateFlagBitsEXT
AccessFlags                                          :: VkAccessFlagBits
ImageAspectFlags                                     :: VkImageAspectFlagBits
FormatFeatureFlags                                   :: VkFormatFeatureFlagBits
ImageCreateFlags                                     :: VkImageCreateFlagBits
SampleCountFlags                                     :: VkSampleCountFlagBits
ImageUsageFlags                                      :: VkImageUsageFlagBits
MemoryHeapFlags                                      :: VkMemoryHeapFlagBits
MemoryPropertyFlags                                  :: VkMemoryPropertyFlagBits
QueueFlags                                           :: VkQueueFlagBits
DeviceQueueCreateFlags                               :: VkDeviceQueueCreateFlagBits
PipelineStageFlags                                   :: VkPipelineStageFlagBits
SparseMemoryBindFlags                                :: VkSparseMemoryBindFlagBits
SparseImageFormatFlags                               :: VkSparseImageFormatFlagBits
FenceCreateFlags                                     :: VkFenceCreateFlagBits
QueryPipelineStatisticFlags                          :: VkQueryPipelineStatisticFlagBits
QueryResultFlags                                     :: VkQueryResultFlagBits
BufferCreateFlags                                    :: VkBufferCreateFlagBits
BufferUsageFlags                                     :: VkBufferUsageFlagBits
ImageViewCreateFlags                                 :: VkImageViewCreateFlagBits
ShaderModuleCreateFlags                              :: VkShaderModuleCreateFlagBits
PipelineCacheCreateFlags                             :: VkPipelineCacheCreateFlagBits
ColorComponentFlags                                  :: VkColorComponentFlagBits
PipelineCreateFlags                                  :: VkPipelineCreateFlagBits
PipelineShaderStageCreateFlags                       :: VkPipelineShaderStageCreateFlagBits
ShaderStageFlags                                     :: VkShaderStageFlagBits
SamplerCreateFlags                                   :: VkSamplerCreateFlagBits
DescriptorPoolCreateFlags                            :: VkDescriptorPoolCreateFlagBits
DescriptorSetLayoutCreateFlags                       :: VkDescriptorSetLayoutCreateFlagBits
AttachmentDescriptionFlags                           :: VkAttachmentDescriptionFlagBits
DependencyFlags                                      :: VkDependencyFlagBits
FramebufferCreateFlags                               :: VkFramebufferCreateFlagBits
RenderPassCreateFlags                                :: VkRenderPassCreateFlagBits
SubpassDescriptionFlags                              :: VkSubpassDescriptionFlagBits
CommandPoolCreateFlags                               :: VkCommandPoolCreateFlagBits
CommandPoolResetFlags                                :: VkCommandPoolResetFlagBits
CommandBufferUsageFlags                              :: VkCommandBufferUsageFlagBits
QueryControlFlags                                    :: VkQueryControlFlagBits
CommandBufferResetFlags                              :: VkCommandBufferResetFlagBits
StencilFaceFlags                                     :: VkStencilFaceFlagBits
SubgroupFeatureFlags                                 :: VkSubgroupFeatureFlagBits
PeerMemoryFeatureFlags                               :: VkPeerMemoryFeatureFlagBits
MemoryAllocateFlags                                  :: VkMemoryAllocateFlagBits
ExternalMemoryHandleTypeFlags                        :: VkExternalMemoryHandleTypeFlagBits
ExternalMemoryFeatureFlags                           :: VkExternalMemoryFeatureFlagBits
ExternalFenceHandleTypeFlags                         :: VkExternalFenceHandleTypeFlagBits
ExternalFenceFeatureFlags                            :: VkExternalFenceFeatureFlagBits
FenceImportFlags                                     :: VkFenceImportFlagBits
SemaphoreImportFlags                                 :: VkSemaphoreImportFlagBits
ExternalSemaphoreHandleTypeFlags                     :: VkExternalSemaphoreHandleTypeFlagBits
ExternalSemaphoreFeatureFlags                        :: VkExternalSemaphoreFeatureFlagBits
ResolveModeFlags                                     :: VkResolveModeFlagBits
DescriptorBindingFlags                               :: VkDescriptorBindingFlagBits
SemaphoreWaitFlags                                   :: VkSemaphoreWaitFlagBits
SurfaceTransformFlagsKHR                             :: VkSurfaceTransformFlagBitsKHR
CompositeAlphaFlagsKHR                               :: VkCompositeAlphaFlagBitsKHR
SwapchainCreateFlagsKHR                              :: VkSwapchainCreateFlagBitsKHR
DeviceGroupPresentModeFlagsKHR                       :: VkDeviceGroupPresentModeFlagBitsKHR
DisplayPlaneAlphaFlagsKHR                            :: VkDisplayPlaneAlphaFlagBitsKHR
PerformanceCounterDescriptionFlagsKHR                :: VkPerformanceCounterDescriptionFlagBitsKHR
AcquireProfilingLockFlagsKHR                         :: VkAcquireProfilingLockFlagBitsKHR
DebugReportFlagsEXT                                  :: VkDebugReportFlagBitsEXT
ExternalMemoryHandleTypeFlagsNV                      :: VkExternalMemoryHandleTypeFlagBitsNV
ExternalMemoryFeatureFlagsNV                         :: VkExternalMemoryFeatureFlagBitsNV
ConditionalRenderingFlagsEXT                         :: VkConditionalRenderingFlagBitsEXT
SurfaceCounterFlagsEXT                               :: VkSurfaceCounterFlagBitsEXT
DebugUtilsMessageSeverityFlagsEXT                    :: VkDebugUtilsMessageSeverityFlagBitsEXT
DebugUtilsMessageTypeFlagsEXT                        :: VkDebugUtilsMessageTypeFlagBitsEXT
GeometryFlagsKHR                                     :: VkGeometryFlagBitsKHR
GeometryInstanceFlagsKHR                             :: VkGeometryInstanceFlagBitsKHR
BuildAccelerationStructureFlagsKHR                   :: VkBuildAccelerationStructureFlagBitsKHR
PipelineCompilerControlFlagsAMD                      :: VkPipelineCompilerControlFlagBitsAMD
PipelineCreationFeedbackFlagsEXT                     :: VkPipelineCreationFeedbackFlagBitsEXT
ShaderCorePropertiesFlagsAMD                         :: VkShaderCorePropertiesFlagBitsAMD
ToolPurposeFlagsEXT                                  :: VkToolPurposeFlagBitsEXT

Version :: (major: u32, minor: u32, patch: u32)

Error :: enum {
    Unknown
    VulkanApi               : VkResult
    UnsupportedLayers       : Array[String]
    UnsupportedExtensions   : Array[String]
    UnsupportedShaderStage  : SpvExecutionModel
    NoShaderEntryPoint      : String
    NoPhysicalDevice
    FsError                 : fs.FsError
    SpirvCrossError         : String
    // MismatchedShaderBufferType : (Shader.Buffer, Shader.Buffer) // this causes the compiler to crash
    Other                   : String
}

impl Into[String] for Error {
    into :: (&Self) -> String {
        return fmt.format("{}", [self])
    }
}

ValidationInfo :: struct #copy {
    message_severity : DebugUtilsMessageSeverityFlagsEXT
    message_type     : DebugUtilsMessageTypeFlagsEXT
    user_callback    : PFN_vkDebugUtilsMessengerCallbackEXT
    user_data        : ^mut void = null
}

Instance :: struct {
    handle : VkInstance = null
}

impl Instance {
    new :: (
        app_name: string = "",
        app_version: Version = (1, 0, 0),
        engine_name: string = "",
        engine_version: Version = (1, 0, 0),
        api_version: Option[Version] = None,
        validation: Option[ValidationInfo] = None,
        layers: []string = [],
        extensions: []string = []
    ) -> Result[Instance, Error] {

        // compute required layers
        required_layers := Array[^char8].new(layers.length + 1)
        for layer in layers do required_layers.add(layer.to_cstring())
        if validation != .None {
            validation_layers := [ "VK_LAYER_KHRONOS_validation" ]
            for layer in validation_layers[..] do required_layers.add(layer.to_cstring())
        }

        defer for layer in required_layers.slice() do mem.free(layer)

        // check if all layers are supported
        supported_layers := enumerate_instance_layer_properties()
        missing_layers := find_missing_requirements(required_layers[..], supported_layers[..], layer => cast(^char8)layer.layerName.data)
        if missing_layers.count() > 0 {
            return Err(Error.UnsupportedLayers(missing_layers))
        }

        // compute required extensions
        required_extensions := Array[^char8].new(extensions.length + 1)
        for extension in extensions do required_extensions.add(extension.to_cstring())
        if validation != .None {
            debug_extensions := [ VK_EXT_DEBUG_UTILS_EXTENSION_NAME ]
            for extension in debug_extensions[..] do required_extensions.add(extension)
        }

        defer for extension in required_extensions.slice() do mem.free(extension)

        // check if all extensions are supported
        supported_extensions := enumerate_instance_extension_properties()
        missing_extensions := find_missing_requirements(required_extensions[..], supported_extensions[..], extension => cast(^char8)extension.extensionName.data)
        if missing_extensions.count() > 0 {
            return Err(Error.UnsupportedExtensions(missing_extensions))
        }

        // compute actual api version
        actual_api_version : Version = {
            mut supported_api_version_encoded : u32 = default
            vkEnumerateInstanceVersion(^mut supported_api_version_encoded)
            supported_api_version : Version = VK_EXTRACT_VERSION(supported_api_version_encoded)
            match api_version {
                Some($version) -> {
                    if u32(version.major) > supported_api_version.major {
                        return Err(Error.VulkanApi(VkResult.ErrorIncompatibleVersionKhr))
                    }
                    if u32(version.major) == supported_api_version.major and
                        u32(version.minor) > supported_api_version.minor {
                        return Err(Error.VulkanApi(VkResult.ErrorIncompatibleVersionKhr))
                    }
                    if u32(version.minor) == supported_api_version.minor and
                        u32(version.patch) > supported_api_version.patch {
                        return Err(Error.VulkanApi(VkResult.ErrorIncompatibleVersionKhr))
                    }
                    u32(version.major), u32(version.minor), u32(version.patch)
                }

                None -> supported_api_version
            }
        }

        app_name_c := app_name.to_cstring()
        defer mem.free(app_name_c)

        engine_name_c := app_name.to_cstring()
        defer mem.free(engine_name_c)

        app_info := VkApplicationInfo(
            sType              = .ApplicationInfo
            pApplicationName   = app_name_c
            applicationVersion = VK_MAKE_VERSION(u32(app_version.major), u32(app_version.minor), u32(app_version.patch))
            pEngineName        = engine_name_c
            engineVersion      = VK_MAKE_VERSION(u32(engine_version.major), u32(engine_version.minor), u32(engine_version.patch))
            apiVersion         = VK_MAKE_VERSION(u32(actual_api_version.major), u32(actual_api_version.minor), u32(actual_api_version.patch))
        )

        mut debug_utils_messenger_create_info := VkDebugUtilsMessengerCreateInfoEXT(.DebugUtilsMessengerCreateInfoExt)
        match validation {
            Some($info) -> {
                debug_utils_messenger_create_info.messageSeverity = info.message_severity
                debug_utils_messenger_create_info.messageType     = info.message_type
                debug_utils_messenger_create_info.pfnUserCallback = info.user_callback
                debug_utils_messenger_create_info.pUserData       = info.user_data
            }
            None -> {}
        }

        create_info := VkInstanceCreateInfo(
            sType                   = .InstanceCreateInfo
            pNext                   = if validation != .None then cast(^mut void) ^mut debug_utils_messenger_create_info else null
            pApplicationInfo        = ^app_info
            enabledLayerCount       = cast required_layers.count()
            ppEnabledLayerNames     = required_layers.get_raw_mut()
            enabledExtensionCount   = cast required_extensions.count()
            ppEnabledExtensionNames = required_extensions.get_raw_mut()
        )

        mut handle : VkInstance = default
        vk_try(vkCreateInstance(^create_info, null, ^mut handle))

        return Ok(Instance(handle))
    }

    destroy :: (&Self) {
        if self.handle != null {
            vkDestroyInstance(self.handle, null)
        }
        @cast(&mut Self, self).handle = null
    }

    enumerate_physical_devices :: (&Self) -> Result[Array[PhysicalDevice], Error] {
        count : u32 = default
        vk_try(vkEnumeratePhysicalDevices(self.handle, ^count, null))
        mut handles := Array[VkPhysicalDevice].new(initial_capacity = cast count)
        handles.resize(cast count)
        vk_try(vkEnumeratePhysicalDevices(self.handle, ^count, handles.get_raw_mut()))


        mut result := Array[PhysicalDevice].new(initial_capacity = cast count)
        for handle in handles[..] {
            result.add(PhysicalDevice.new(handle))
        }

        return Ok(result)
    }

    get_instance_proc :: (&Self, name: string, $T: type) -> Result[T, Error] {
        name_c := name.to_cstring()
        defer mem.free(name_c)
        proc := vkGetInstanceProcAddr(self.handle, name_c)
        if proc == null {
            return Err(Error.VulkanApi(VkResult.ErrorExtensionNotPresent))
        }
        return Ok(cast(T) proc)
    }

    // vkEnumeratePhysicalDeviceGroups :: (&Self, _pPhysicalDeviceGroupCount: ^mut uint32_t, _pPhysicalDeviceGroupProperties: ^mut VkPhysicalDeviceGroupProperties) -> VkResult {
    // }

    // vkDestroySurfaceKHR :: (&Self, _surface: VkSurfaceKHR, _pAllocator: ^mut VkAllocationCallbacks) {
    // }

    // vkCreateDisplayPlaneSurfaceKHR :: (&Self, _pCreateInfo: ^mut VkDisplaySurfaceCreateInfoKHR, _pAllocator: ^mut VkAllocationCallbacks, _pSurface: ^mut VkSurfaceKHR) -> VkResult {
    // }

    create_surface_glfw :: (&Self, window: ^GLFWwindow) -> Result[Surface, Error] {
        glfwCreateWindowSurface :: (instance: VkInstance, window: ^GLFWwindow, allocator: ^VkAllocationCallbacks, surface: ^mut VkSurfaceKHR) -> VkResult #linkname("glfwCreateWindowSurface");
        mut handle : VkSurfaceKHR = default
        vk_try(glfwCreateWindowSurface(self.handle, window, null, ^mut handle))
        return Ok(Surface.new(handle, self))
    }

    create_debug_messenger :: (&Self, validation: ValidationInfo) -> Result[DebugUtilsMessenger, Error] {
        vkCreateDebugUtilsMessengerEXT := try(self.get_instance_proc("vkCreateDebugUtilsMessengerEXT", PFN_vkCreateDebugUtilsMessengerEXT))
        create_info := VkDebugUtilsMessengerCreateInfoEXT(
            sType           = .DebugUtilsMessengerCreateInfoExt
            messageSeverity = validation.message_severity
            messageType     = validation.message_type
            pfnUserCallback = validation.user_callback
            pUserData       = validation.user_data
        )

        mut handle : VkDebugUtilsMessengerEXT = default
        vk_try(vkCreateDebugUtilsMessengerEXT(self.handle, ^create_info, null, ^mut handle))
        return Ok(DebugUtilsMessenger.new(handle, self))
    }
}

impl Drop for Instance {
    drop :: (&Self) {
        self.destroy()
    }
}

PhysicalDevice :: struct {
    handle                  : VkPhysicalDevice
    properties              : VkPhysicalDeviceProperties
    features                : VkPhysicalDeviceFeatures
    queue_family_properties : Array[VkQueueFamilyProperties]
}

impl PhysicalDevice {
    new :: (handle: VkPhysicalDevice) -> PhysicalDevice {
        mut properties := VkPhysicalDeviceProperties()
        mut features := VkPhysicalDeviceFeatures()
        vkGetPhysicalDeviceProperties(handle, ^mut properties)
        vkGetPhysicalDeviceFeatures(handle, ^mut features)

        queue_family_properties := get_physical_device_queue_family_properties(handle)

        return PhysicalDevice(
            handle                  = handle
            properties              = properties
            features                = features
            queue_family_properties = queue_family_properties
        )
    }

    get_queue_families_with :: (&Self, flags: QueueFlags) -> Array[u32] {
        result := Array[u32].new(self.queue_family_properties.count())
        for props, i in self.queue_family_properties[..] {
            if flags is in props.queueFlags {
                result.add(u32(i))
            }
        }
        return result
    }

    get_queue_families_with_present :: (&Self, surface: &Surface) -> Array[u32] {
        result := Array[u32].new(self.queue_family_properties.count())
        for props, i in self.queue_family_properties[..] {
            mut present_support : VkBool32 = 0
            vkGetPhysicalDeviceSurfaceSupportKHR(self.handle, cast i, surface.handle, ^mut present_support)
            if present_support != 0 {
                result.add(u32(i))
            }
        }
        return result
    }

    get_surface_formats :: (&Self, surface: &Surface) -> Array[VkSurfaceFormatKHR] {
        count : u32 = default
        vkGetPhysicalDeviceSurfaceFormatsKHR(self.handle, surface.handle, ^count, null)
        mut result := Array[VkSurfaceFormatKHR].new(initial_capacity = cast count)
        result.resize(cast count)
        vkGetPhysicalDeviceSurfaceFormatsKHR(self.handle, surface.handle, ^count, result.get_raw_mut())
        return result
    }

    get_surface_present_modes :: (&Self, surface: &Surface) -> Array[VkPresentModeKHR] {
        count : u32 = default
        vkGetPhysicalDeviceSurfacePresentModesKHR(self.handle, surface.handle, ^count, null)
        mut result := Array[VkPresentModeKHR].new(initial_capacity = cast count)
        result.length = cast count // can't use resize because VkPresentModeKHR is an enum. @TODO: fix
        vkGetPhysicalDeviceSurfacePresentModesKHR(self.handle, surface.handle, ^count, result.get_raw_mut())
        return result
    }

    get_swapchain_support_details :: (&Self, surface: &Surface) -> PhysicalDeviceSurfaceCapabilities {
        mut details := PhysicalDeviceSurfaceCapabilities(
            physical_device = self.handle
            formats         = self.get_surface_formats(surface)
            present_modes   = self.get_surface_present_modes(surface)
        )

        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(self.handle, surface.handle, ^mut details.capabilities)

        return details
    }

    filter_by_requirements :: (devices: []PhysicalDevice, extensions: []string, queues: []QueueFlags, present: Option[&Surface], swapchain: Option[&Surface]) -> Array[&PhysicalDevice] {
        // compute required extensions
        required_extensions := Array[^char8].new(extensions.length + 1)
        for extension in extensions do required_extensions.add(extension.to_cstring())

        defer for extension in required_extensions.slice() do mem.free(extension)

        // filter devices
        mut result := Array[&PhysicalDevice].new(devices.length)
        for &device in devices #label device_loop {
            // check extensions
            supported_extensions := enumerate_device_extension_properties(device.handle)
            missing_extensions := find_missing_requirements(required_extensions[..], supported_extensions[..], extension => cast(^char8)extension.extensionName.data)
            if missing_extensions.count() > 0 {
                continue device_loop
            }

            // check queue families
            for queue in queues {
                families := device.get_queue_families_with(queue)
                if families.count() == 0 {
                    continue device_loop
                }
            }
            match present {
                Some($surface) -> {
                    families := device.get_queue_families_with_present(surface)
                    if families.count() == 0 {
                        continue device_loop
                    }
                }
                None -> {}
            }

            // check swapchain support
            match swapchain {
                Some($surface) -> {
                    swapchain_support := device.get_swapchain_support_details(surface)
                    if swapchain_support.formats.count() == 0 or swapchain_support.present_modes.count() == 0 {
                        continue device_loop
                    }
                }
                None -> {}
            }

            result.add(device)
        }

        return result
    }

    get_surface_formats :: (&Self, surface: &Surface) -> Array[VkSurfaceFormatKHR] {
        count : u32 = default
        vkGetPhysicalDeviceSurfaceFormatsKHR(self.handle, surface.handle, ^count, null)
        mut result := Array[VkSurfaceFormatKHR].new(initial_capacity = cast count)
        result.resize(cast count)
        vkGetPhysicalDeviceSurfaceFormatsKHR(self.handle, surface.handle, ^count, result.get_raw_mut())
        return result
    }

    get_surface_present_modes :: (&Self, surface: &Surface) -> Array[VkPresentModeKHR] {
        count : u32 = default
        vkGetPhysicalDeviceSurfacePresentModesKHR(self.handle, surface.handle, ^count, null)
        mut result := Array[VkPresentModeKHR].new(initial_capacity = cast count)
        result.length = cast count // can't use resize because VkPresentModeKHR is an enum. @TODO: fix
        vkGetPhysicalDeviceSurfacePresentModesKHR(self.handle, surface.handle, ^count, result.get_raw_mut())
        return result
    }

    query_swapchain_support :: (&Self, surface: &Surface) -> PhysicalDeviceSurfaceCapabilities {
        mut details := PhysicalDeviceSurfaceCapabilities(
            physical_device = self.handle
            formats         = get_surface_formats(surface)
            present_modes   = get_surface_present_modes(surface)
        )

        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(self.handle, surface.handle, ^mut details.capabilities)

        return details
    }
}

PhysicalDeviceSurfaceCapabilities :: struct {
    physical_device : VkPhysicalDevice
    capabilities    : VkSurfaceCapabilitiesKHR = default
    formats         := Array[VkSurfaceFormatKHR].new()
    present_modes   := Array[VkPresentModeKHR].new()
}

impl PhysicalDeviceSurfaceCapabilities {
    update_capabilities :: (&mut Self, surface: &Surface) {
        vkGetPhysicalDeviceSurfaceCapabilitiesKHR(self.physical_device, surface.handle, ^mut self.capabilities)
    }

    choose_image_count :: (&Self) -> u32 {
        mut image_count := self.capabilities.minImageCount + 1
        if self.capabilities.maxImageCount > 0 and image_count > self.capabilities.maxImageCount {
            image_count = self.capabilities.maxImageCount
        }
        return image_count
    }

    choose_swap_extent :: (&Self, fallback_extent: VkExtent2D) -> VkExtent2D {
        if self.capabilities.currentExtent.width != u32.max {
            return self.capabilities.currentExtent
        }

        mut actual_extent := fallback_extent
        actual_extent.width = clamp(actual_extent.width, self.capabilities.minImageExtent.width, self.capabilities.maxImageExtent.width)
        actual_extent.height = clamp(actual_extent.height, self.capabilities.minImageExtent.height, self.capabilities.maxImageExtent.height)
        return actual_extent
    }

    choose_swap_present_mode :: (&Self, preferred_mode: VkPresentModeKHR) -> VkPresentModeKHR {
        for mode in self.present_modes[..] {
            if mode == preferred_mode {
                return mode
            }
        }

        return .FifoKhr
    }

    choose_swap_surface_format :: (&Self, preferred_format: VkFormat, preferred_colorspace: VkColorSpaceKHR) -> VkSurfaceFormatKHR {
        for format in self.formats[..] {
            if format.format == preferred_format and format.colorSpace == preferred_colorspace {
                return format
            }
        }

        return *formats[0]
    }
}

Device :: struct {
    handle          : VkDevice
    physical_device : VkPhysicalDevice
}

DeviceQueueCreateInfo :: struct {
    flags       := DeviceQueueCreateFlags.None
    family      : u32
    priorities  : []f32 = [1.0]
}

impl Device {
    new :: (
        physical_device: &PhysicalDevice,
        extensions: []string,
        queues: []DeviceQueueCreateInfo,
        features: ^VkPhysicalDeviceFeatures2) -> Result[Device, Error] {
        required_extensions := Array[^char8].new(extensions.length + 1)
        for extension in extensions do required_extensions.add(extension.to_cstring())
        defer for extension in required_extensions.slice() do mem.free(extension)

        queue_create_infos := Array[VkDeviceQueueCreateInfo].new()

        for &queue in queues {
            queue_create_infos.add(VkDeviceQueueCreateInfo(
                sType               = .DeviceQueueCreateInfo
                flags               = queue.flags
                queueFamilyIndex    = queue.family
                queueCount          = cast queue.priorities.length
                pQueuePriorities    = queue.priorities.data
            ))
        }

        create_info := VkDeviceCreateInfo(
            sType                   = .DeviceCreateInfo
            pNext                   = features
            queueCreateInfoCount    = cast queue_create_infos.count()
            pQueueCreateInfos       = queue_create_infos.get_raw_mut()
            enabledExtensionCount   = cast required_extensions.count()
            ppEnabledExtensionNames = required_extensions.get_raw_mut()
            pEnabledFeatures        = null
        )

        mut handle : VkDevice = default
        vk_try(vkCreateDevice(physical_device.handle, ^create_info, null, ^mut handle))

        return Ok(Device(handle, physical_device.handle))
    }

    get_memory_type :: (&Self, memory_type_bits: u32, flags: VkMemoryPropertyFlagBits) -> Option[u32] {
        mut properties : VkPhysicalDeviceMemoryProperties = default
        vkGetPhysicalDeviceMemoryProperties(self.physical_device, ^mut properties)
        for typ in properties.memoryTypes[..i64(properties.memoryTypeCount)] {
            is_possible_type := @bin_and(@bin_lsl(1, u32(it_index)), memory_type_bits) != 0
            if is_possible_type and (flags is in typ.propertyFlags) {
                return .Some(u32(it_index))
            }
        }
        return .None
    }

    get_queue :: (&Self, family: u32) -> Queue {
        mut handle : VkQueue = default
        vkGetDeviceQueue(self.handle, family, 0, ^mut handle)
        return Queue.new(handle)
    }

    destroy :: (&Self) {
        if self.handle != null {
            vkDestroyDevice(self.handle, null)
        }
        @cast(&mut Self, self).handle = null
    }
}

impl Drop for Device {
    drop :: (&Self) {
        self.destroy()
    }
}

Queue :: struct #copy {
    handle : VkQueue
}

impl Queue {
    new :: (handle: VkQueue) -> Queue {
        return Queue(handle)
    }
}

Surface :: struct {
    handle      : VkSurfaceKHR
    instance    : VkInstance
}

impl Surface {
    new :: (handle: VkSurfaceKHR, instance: &Instance) -> Surface {
        return Surface(handle, instance.handle)
    }

    destroy :: (&Self) {
        if self.handle != null {
            vkDestroySurfaceKHR(self.instance, self.handle, null)
        }
        @cast(&mut Self, self).handle = null
    }

}

impl Drop for Surface {
    drop :: (&Self) {
        self.destroy()
    }
}

DebugUtilsMessenger :: struct {
    handle      : VkDebugUtilsMessengerEXT
    instance    : VkInstance
}

impl DebugUtilsMessenger {
    new :: (handle: VkDebugUtilsMessengerEXT, instance: &Instance) -> DebugUtilsMessenger {
        return DebugUtilsMessenger(handle, instance.handle)
    }

    destroy :: (&Self) {
        if self.handle != null {
            vkDestroyDebugUtilsMessengerEXT := cast(PFN_vkDestroyDebugUtilsMessengerEXT) vkGetInstanceProcAddr(self.instance, "vkDestroyDebugUtilsMessengerEXT"c)
            @assert(vkDestroyDebugUtilsMessengerEXT != null)
            vkDestroyDebugUtilsMessengerEXT(self.instance, self.handle, null)
        }
        @cast(&mut Self, self).handle = null
    }
}

impl Drop for DebugUtilsMessenger {
    drop :: (&Self) {
        self.destroy()
    }
}

Swapchain :: struct {
    handle              : VkSwapchainKHR
    device              : VkDevice
    image_format        : VkFormat
    extent              : VkExtent2D
    images              : Array[VkImage]
    image_views         : Array[VkImageView]
    depth_images        : Array[Image]
    depth_image_views   : Array[VkImageView]
    framebuffers        : Array[VkFramebuffer]
}

impl Swapchain {
    new :: (
        device: &Device,
        physical_device: &PhysicalDevice,
        surface: &Surface,
        queue_family_indices: []u32,
        extent: VkExtent2D,
        image_format: VkFormat,
        color_space: VkColorSpaceKHR,
        present_mode: VkPresentModeKHR,
        image_count: u32,
        pre_transform: VkSurfaceTransformFlagsKHR) -> Result[Rc[Swapchain], Error] {

        mut create_info := VkSwapchainCreateInfoKHR(
            sType                   = .SwapchainCreateInfoKhr
            flags                   = .None
            surface                 = surface.handle
            minImageCount           = image_count
            imageFormat             = image_format
            imageColorSpace         = color_space
            imageExtent             = extent
            imageArrayLayers        = 1
            imageUsage              = .ColorAttachmentBit
            preTransform            = pre_transform
            compositeAlpha          = .OpaqueBitKhr
            presentMode             = present_mode
            clipped                 = VK_TRUE
            oldSwapchain            = null
        )

        unique_indices := Map[u32, ()].new()
        for index in queue_family_indices {
            unique_indices.set(index, ())
        }
        if unique_indices.count() <= 1 {
            create_info.imageSharingMode = .Exclusive
            create_info.queueFamilyIndexCount = 0
            create_info.pQueueFamilyIndices = null
        } else {
            create_info.imageSharingMode = .Concurrent
            create_info.queueFamilyIndexCount = cast queue_family_indices.length
            create_info.pQueueFamilyIndices = cast(^mut u32) queue_family_indices.data
        }

        mut handle : VkSwapchainKHR = default
        vkCreateSwapchainKHR(device.handle, ^mut create_info, null, ^mut handle)

        vkGetSwapchainImagesKHR(device.handle, handle, ^mut image_count, null)
        images := Array[VkImage].new()
        images.resize(cast image_count)
        vkGetSwapchainImagesKHR(device.handle, handle, ^mut image_count, images.get_raw_mut())

        return Ok(Rc[Swapchain].new(Swapchain(
            handle              = handle
            device              = device.handle
            image_format        = image_format
            extent              = extent
            images              = images
            image_views         = Array[VkImageView].new(initial_capacity = cast image_count)
            depth_images        = Array[Image].new(initial_capacity = cast image_count)
            depth_image_views   = Array[VkImageView].new(initial_capacity = cast image_count)
            framebuffers        = Array[VkFramebuffer].new(initial_capacity = cast image_count)
        )))
    }

    get_images :: (&Self) -> []VkImage {
        return self.images[..]
    }

    get_image_views :: (&Self) -> []VkImageView {
        return self.image_views[..]
    }

    create_image_views :: (&mut Self) -> Result[(), Error] {
        self.image_views.resize(self.images.count())

        for image, i in self.images[..] {
            create_info := VkImageViewCreateInfo(
                sType            = .ImageViewCreateInfo
                image            = image
                viewType         = ._2d
                format           = self.image_format
                components       = VkComponentMapping(
                    r = .Identity
                    g = .Identity
                    b = .Identity
                    a = .Identity
                )
                subresourceRange = VkImageSubresourceRange(
                    aspectMask     = .ColorBit
                    baseMipLevel   = 0
                    levelCount     = 1
                    baseArrayLayer = 0
                    layerCount     = 1
                )
            )

            vk_try(vkCreateImageView(self.device, ^create_info, null, ^mut *self.image_views[i]))
        }

        return Ok()
    }

    get_depth_images :: (&Self) -> []Image {
        return self.depth_images[..]
    }

    get_depth_image_views :: (&Self) -> []VkImageView {
        return self.depth_image_views[..]
    }

    create_depth_images :: (&mut Self, device: &Device) -> Result[(), Error] {
        for i in 0 .. self.images.count() {
            image := try(Image.new_2d(device, self.extent, .D32Sfloat, .DepthStencilAttachmentBit))
            self.depth_images.add(image)
        }

        return Ok()
    }

    create_depth_image_views :: (&mut Self) -> Result[(), Error] {
        self.depth_image_views.resize(self.depth_images.count())

        for image, i in self.depth_images[..] {
            create_info := VkImageViewCreateInfo(
                sType            = .ImageViewCreateInfo
                image            = image.handle
                viewType         = ._2d
                format           = .D32Sfloat
                components       = VkComponentMapping(
                    r = .Identity
                    g = .Identity
                    b = .Identity
                    a = .Identity
                )
                subresourceRange = VkImageSubresourceRange(
                    aspectMask     = .DepthBit
                    baseMipLevel   = 0
                    levelCount     = 1
                    baseArrayLayer = 0
                    layerCount     = 1
                )
            )

            vk_try(vkCreateImageView(self.device, ^create_info, null, ^mut *self.depth_image_views[i]))
        }

        return Ok()
    }

    get_framebuffers :: (&Self) -> []VkFramebuffer {
        return self.framebuffers[..]
    }

    create_framebuffers :: (&mut Self, render_pass: VkRenderPass) -> Result[(), Error] {
        self.framebuffers.resize(self.image_views.count())

        use_depth := self.depth_images.count() > 0

        for view, i in self.get_image_views() {
            with_depth := [view, *self.depth_image_views[i]]
            without_depth := [view]
            attachments : []mut VkImageView = if use_depth then with_depth[..] else without_depth[..]
            framebuffer_info := VkFramebufferCreateInfo(
                sType           = .FramebufferCreateInfo
                renderPass      = render_pass
                attachmentCount = cast attachments.length
                pAttachments    = attachments.data
                width           = self.extent.width
                height          = self.extent.height
                layers          = 1
            )

            vk_try(vkCreateFramebuffer(self.device, ^framebuffer_info, null, ^mut *self.framebuffers[i]))
        }

        return Ok()
    }

    destroy :: (&Self) {
        for &depth_image in self.depth_images[..] {
            depth_image.destroy(self.device)
        }
        self.depth_images.clear()
        for depth_image_view in self.depth_image_views[..] {
            vkDestroyImageView(self.device, depth_image_view, null)
        }
        self.depth_image_views.clear()

        if self.handle != null {
            vkDestroySwapchainKHR(self.device, self.handle, null)
        }
        @cast(&mut Self, self).handle = null
    }
}

impl Drop for Swapchain {
    drop :: (&Self) {
        self.destroy()
    }
}

ShaderBuffer :: struct {
    typ : VkDescriptorType
    set : u32
    binding : u32
    stage : VkShaderStageFlags
}

Shader :: struct {
    StageInput :: struct {
        location    : u32
        offset      : u32
        typ         : &TypeInfo
    }

    module  : VkShaderModule
    entry   : String
    stage   : VkShaderStageFlags

    vertex_input_binding : VkVertexInputBindingDescription
    stage_inputs : Array[StageInput]
    buffers : Array[ShaderBuffer]
}

impl Shader {
    new :: (device: &Device, path: string) -> Result[Shader, Error] {
        shader_code := try_with(fs.read_file_binary(path), { return Err(Error.FsError(err)) })
        code := shader_code.slice().reinterpret_cast(u32)

        // extract info from spirv
        mut context : spvc_context = default
        spvc_try(spvc_context_create(^mut context))
        defer spvc_context_destroy(context)


        mut ir : spvc_parsed_ir = default
        spvc_try(spvc_context_parse_spirv(context, cast code.data, cast code.length, ^mut ir))

        compiler : spvc_compiler = default
        spvc_try(spvc_context_create_compiler(context, .Glsl, ir, .Copy, ^mut compiler))

        // get shader stage
        stage : VkShaderStageFlags = match spvc_compiler_get_execution_model(compiler) {
            .Vertex -> VkShaderStageFlags.VertexBit
            .Fragment -> VkShaderStageFlags.FragmentBit
            .Geometry -> VkShaderStageFlags.GeometryBit
            $stage -> {
                return Err(Error.UnsupportedShaderStage(stage))
            }
        }

        // get entry point
        mut entry_points : []spvc_entry_point = default
        spvc_compiler_get_entry_points(compiler, cast ^entry_points.data, cast ^mut entry_points.length)

        if entry_points.length <= 0 {
            return Err(Error.NoShaderEntryPoint(path.to_owned()))
        }

        mut resources : spvc_resources = default
        spvc_try(spvc_compiler_create_shader_resources(compiler, ^mut resources))


        // get input stages
        mut stage_input_array := Array[Shader.StageInput].new()
        mut offset : u32 = 0
        mut stage_inputs : []spvc_reflected_resource = default
        spvc_try(spvc_resources_get_resource_list_for_type(resources, .StageInput, cast ^stage_inputs.data, cast ^stage_inputs.length))
        for &input in stage_inputs {
            location := spvc_compiler_get_decoration(compiler, input.id, .Location)
            stage_input_array.add(Shader.StageInput(
                location    = location
                offset      = offset
                typ         = match location {
                    0 -> &*@type_info(Vector4[f32])
                    1 -> &*@type_info(Vector4[f32])
                    2 -> &*@type_info(Vector4[f32])
                    _ -> @assert(false)
                }
            ))

            offset += u32(stage_input_array.peek_last().typ.size)
        }

        mut vertex_input_binding := VkVertexInputBindingDescription(
            binding = 0
            inputRate = .Vertex
            stride = 0
        )
        for &input in stage_input_array.slice() {
            vertex_input_binding.stride += u32(input.typ.size)
        }

        // storage and uniform buffers
        mut all_buffers := Array[ShaderBuffer].new()

        mut storage_buffers : []spvc_reflected_resource = default
        spvc_try(spvc_resources_get_resource_list_for_type(resources, .StorageBuffer, cast ^storage_buffers.data, cast ^storage_buffers.length))

        for &sb in storage_buffers {
            binding := spvc_compiler_get_decoration(compiler, sb.id, .Binding)
            set := spvc_compiler_get_decoration(compiler, sb.id, .DescriptorSet)
            all_buffers.add(ShaderBuffer(
                typ     = .StorageBuffer
                binding = binding
                set     = set
                stage   = stage
            ))
        }

        mut uniform_buffers : []spvc_reflected_resource = default
        spvc_try(spvc_resources_get_resource_list_for_type(resources, .UniformBuffer, cast ^uniform_buffers.data, cast ^uniform_buffers.length))

        for &ub in uniform_buffers {
            binding := spvc_compiler_get_decoration(compiler, ub.id, .Binding)
            set := spvc_compiler_get_decoration(compiler, ub.id, .DescriptorSet)
            all_buffers.add(ShaderBuffer(
                typ     = .UniformBuffer
                binding = binding
                set     = set
                stage   = stage
            ))
        }

        // create vulkan shader module
        module := try(create_shader_module(device, shader_code.slice()))

        return Ok(Shader(
            module = module
            stage  = stage
            entry  = String.from_cstring(entry_points[0].name)
            vertex_input_binding    = vertex_input_binding
            stage_inputs            = stage_input_array
            buffers                 = all_buffers
        ))
    }

    create_shader_module :: (device: &Device, code: []u8) -> Result[VkShaderModule, Error] {
        create_info := VkShaderModuleCreateInfo(
            sType    = .ShaderModuleCreateInfo
            codeSize = cast code.length
            pCode    = cast(^mut u32) code.data
        )

        mut module : VkShaderModule = default
        vk_try(vkCreateShaderModule(device.handle, ^create_info, null, ^mut module))

        return Ok(module)
    }

    destroy :: (&Self, device: VkDevice) {
        vkDestroyShaderModule(device, self.module, null)
    }
}

GraphicsPipelineSpec :: struct {
    name    := String.from_string("Graphics Pipeline")
    shaders := Array[String].new()

}

GraphicsPipeline :: struct {
    spec                : GraphicsPipelineSpec = default
    handle              : VkPipeline = default
    device              : VkDevice = default
    cache               : VkPipelineCache = default
    layout              : VkPipelineLayout = default
    frame_set_layout    : VkDescriptorSetLayout = default
    mesh_set_layout     : VkDescriptorSetLayout = default
    frame_descriptors   := Array[VkDescriptorSet].new()
}

type_info_to_vulkan_format :: (typ: &TypeInfo) -> VkFormat {
    return match ^*typ {
        $T if T == @type_info(f32) -> .R32Sfloat
        $T if T == @type_info(Vector2[f32]) -> .R32g32Sfloat
        $T if T == @type_info(Vector3[f32]) -> .R32g32b32Sfloat
        $T if T == @type_info(Vector4[f32]) -> .R32g32b32a32Sfloat
        _ -> @assert(false, "Not implemented")
    }
}

impl GraphicsPipeline {
    new :: (cache: VkPipelineCache, spec: GraphicsPipelineSpec) -> GraphicsPipeline {
        return GraphicsPipeline(
            spec    = spec
            cache   = cache
        )
    }

    create :: (&mut Self, device: &Device, render_pass: VkRenderPass) -> Result[(), Error] {
        shaders := Array[Shader].new(self.spec.shaders.count())
        defer {
            for &shader in shaders[..] {
                shader.destroy(device.handle)
            }
        }
        for &file in self.spec.shaders[..] {
            shaders.add(try(Shader.new(device, file.slice())))
        }


        shader_stages := Array[VkPipelineShaderStageCreateInfo].new(shaders.count())
        for &shader in shaders[..] {
            shader_stages.add(VkPipelineShaderStageCreateInfo(
                sType   = .PipelineShaderStageCreateInfo
                stage   = shader.stage
                module  = shader.module
                pName   = "main"c
            ))
        }

        vertex_input_info := VkPipelineVertexInputStateCreateInfo(
            sType                           = .PipelineVertexInputStateCreateInfo
            vertexBindingDescriptionCount   = 0
            pVertexBindingDescriptions      = null
            vertexAttributeDescriptionCount = 0
            pVertexAttributeDescriptions    = null
        )

        input_assembly := VkPipelineInputAssemblyStateCreateInfo(
            sType                  = .PipelineInputAssemblyStateCreateInfo
            topology               = .TriangleList
            primitiveRestartEnable = VK_FALSE
        )

        viewport_state := VkPipelineViewportStateCreateInfo(
            sType         = .PipelineViewportStateCreateInfo
            viewportCount = 1
            pViewports    = null
            scissorCount  = 1
            pScissors     = null
        )

        rasterizer := VkPipelineRasterizationStateCreateInfo(
            sType                   = .PipelineRasterizationStateCreateInfo
            depthClampEnable        = VK_FALSE
            rasterizerDiscardEnable = VK_FALSE
            polygonMode             = .Fill
            cullMode                = .BackBit
            frontFace               = .Clockwise
            depthBiasEnable         = VK_FALSE
            depthBiasConstantFactor = 0.0
            depthBiasClamp          = 0.0
            depthBiasSlopeFactor    = 0.0
            lineWidth               = 1.0
        )

        multisampling := VkPipelineMultisampleStateCreateInfo(
            sType                 = .PipelineMultisampleStateCreateInfo
            rasterizationSamples  = ._1Bit
            sampleShadingEnable   = VK_FALSE
            minSampleShading      = 1.0
            pSampleMask           = null
            alphaToCoverageEnable = VK_FALSE
            alphaToOneEnable      = VK_FALSE
        )

        color_blend_attachment := VkPipelineColorBlendAttachmentState(
            blendEnable         = VK_FALSE
            srcColorBlendFactor = .SrcAlpha
            dstColorBlendFactor = .OneMinusSrcAlpha
            colorBlendOp        = .Add
            srcAlphaBlendFactor = .One
            dstAlphaBlendFactor = .Zero
            alphaBlendOp        = .Add
            colorWriteMask      = .RBit or .GBit or .BBit or .ABit
        )

        color_blending := VkPipelineColorBlendStateCreateInfo(
            sType           = .PipelineColorBlendStateCreateInfo
            logicOpEnable   = VK_FALSE
            logicOp         = .Copy
            attachmentCount = 1
            pAttachments    = ^color_blend_attachment
            blendConstants  = [0.0, 0.0, 0.0, 0.0]
        )

        depth_stencil := VkPipelineDepthStencilStateCreateInfo(
            sType                   = .PipelineDepthStencilStateCreateInfo
            depthTestEnable         = VK_TRUE
            depthWriteEnable        = VK_TRUE
            depthCompareOp          = .LessOrEqual
            depthBoundsTestEnable   = VK_FALSE
            stencilTestEnable       = VK_FALSE
            minDepthBounds          = 0.0
            maxDepthBounds          = 1.0
        )

        set_layouts := try(compute_descriptor_set_layouts(device.handle, shaders[..]))

        pipline_layout_info := VkPipelineLayoutCreateInfo(
            sType                  = .PipelineLayoutCreateInfo
            setLayoutCount         = cast set_layouts.count()
            pSetLayouts            = set_layouts.get_raw_mut()
            pushConstantRangeCount = 0
            pPushConstantRanges    = null
        )

        mut pipeline_layout : VkPipelineLayout = default
        vk_try(vkCreatePipelineLayout(device.handle, ^pipline_layout_info, null, ^mut pipeline_layout))

        mut dynamic_states : []VkDynamicState = [ VkDynamicState.Scissor, VkDynamicState.Viewport ]
        dynamic_state := VkPipelineDynamicStateCreateInfo(
            sType               = .PipelineDynamicStateCreateInfo
            dynamicStateCount   = cast dynamic_states.length
            pDynamicStates      = cast(^mut VkDynamicState) dynamic_states.data
        )

        pipeline_info := VkGraphicsPipelineCreateInfo(
            sType               = .GraphicsPipelineCreateInfo
            stageCount          = cast shader_stages.count()
            pStages             = shader_stages.get_raw_mut()
            pVertexInputState   = ^vertex_input_info
            pInputAssemblyState = ^input_assembly
            pTessellationState  = null
            pViewportState      = ^viewport_state
            pRasterizationState = ^rasterizer
            pMultisampleState   = ^multisampling
            pDepthStencilState  = ^depth_stencil
            pColorBlendState    = ^color_blending
            pDynamicState       = ^dynamic_state
            layout              = pipeline_layout
            renderPass          = render_pass
            subpass             = 0
            basePipelineHandle  = null
            basePipelineIndex   = -1
        )

        mut handle : VkPipeline = default
        vk_try(vkCreateGraphicsPipelines(device.handle, cache, 1, ^pipeline_info, null, ^mut handle))

        self.device = device.handle
        self.handle = handle
        self.layout = pipeline_layout
        self.frame_set_layout = *set_layouts[0]
        self.mesh_set_layout = *set_layouts[1]
        return Ok()
    }

    recreate :: (&mut Self, device: &Device, render_pass: VkRenderPass) -> Result[(), Error] {
        handle := self.handle
        layout := self.layout
        mesh_set_layout := self.mesh_set_layout
        frame_set_layout := self.frame_set_layout

        return match self.create(device, render_pass) {
            Ok(_) -> {
                vkDeviceWaitIdle(device.handle)
                if frame_set_layout != null then vkDestroyDescriptorSetLayout(device.handle, frame_set_layout, null)
                if mesh_set_layout != null then vkDestroyDescriptorSetLayout(device.handle, mesh_set_layout, null)
                if layout != null then vkDestroyPipelineLayout(device.handle, layout, null)
                if handle != null then vkDestroyPipeline(device.handle, handle, null)
                Ok()
            }
            $err -> err
        }
    }

    compute_descriptor_set_layouts :: (device: VkDevice, shaders: []Shader) -> Result[Array[VkDescriptorSetLayout], Error] {
        sets := Map[u32, Array[&mut ShaderBuffer]].new()
        for &shader in shaders {
            for &buffer in shader.buffers[..] {
                buffers := sets.get_or_insert(buffer.set, () => Array[&mut ShaderBuffer].new())

                mut found_existing := false
                for existing in buffers.slice() {
                    if existing.binding == buffer.binding {
                        existing.stage = existing.stage or buffer.stage
                        if existing.typ != buffer.typ {
                            return Err(Error.Other(fmt.format("Mismatched shader buffer types: {} and {}", [*existing, *buffer])))
                        }
                        found_existing = true
                        break
                    }
                }
                if !found_existing then buffers.add(cast buffer)
            }
        }


        mut set_layouts := Array[VkDescriptorSetLayout].new(sets.count())
        set_layouts.resize(sets.count())

        for kv in &sets {
            bindings := Array[VkDescriptorSetLayoutBinding].new(kv.value.count())
            for buff in kv.value.slice() {
                bindings.add(VkDescriptorSetLayoutBinding(
                    binding         = buff.binding
                    descriptorType  = buff.typ
                    descriptorCount = 1
                    stageFlags      = buff.stage
                ))
            }
            mut layout_create_info := VkDescriptorSetLayoutCreateInfo(
                sType           = .DescriptorSetLayoutCreateInfo
                bindingCount    = cast bindings.count()
                pBindings       = bindings.get_raw_mut()
            )
            mut set_layout : VkDescriptorSetLayout = default
            vk_try(vkCreateDescriptorSetLayout(device, ^layout_create_info, null, ^mut set_layout))
            *set_layouts[it_index] = set_layout
        }
        return Ok(set_layouts)
    }

    get_frame_descriptors :: (&Self) -> []VkDescriptorSet {
        return self.frame_descriptors[..]
    }

    create_frame_descriptors :: (&mut Self, count: int, descriptor_pool: VkDescriptorPool) -> Result[(), Error] {
        descriptor_set_layouts := [self.frame_set_layout]
        descriptor_alloc_info := VkDescriptorSetAllocateInfo(
            sType               = .DescriptorSetAllocateInfo
            descriptorPool      = descriptor_pool
            descriptorSetCount  = cast descriptor_set_layouts.length
            pSetLayouts         = descriptor_set_layouts.data
        )

        if self.frame_descriptors.count() > 0 {
            for desc in self.frame_descriptors[..] {
                vkFreeDescriptorSets(self.device, descriptor_pool, 1, ^desc)
            }
            self.frame_descriptors.clear()
        }

        for i in 0 .. count {
            mut fd : VkDescriptorSet = default
            vk_try(vkAllocateDescriptorSets(self.device, ^descriptor_alloc_info, ^mut fd))
            self.frame_descriptors.add(fd)
        }

        return Ok()
    }

    destroy :: (&Self) {
        if frame_set_layout != null then vkDestroyDescriptorSetLayout(device, frame_set_layout, null)
        if mesh_set_layout != null then vkDestroyDescriptorSetLayout(device, mesh_set_layout, null)
        if layout != null then vkDestroyPipelineLayout(device, layout, null)
        if handle != null then vkDestroyPipeline(device, handle, null)
    }
}

Image :: struct {
    handle : VkImage = default
    memory : VkDeviceMemory = default
}

impl Image {
    new_2d :: (device: &Device, extent: VkExtent2D, format: VkFormat, usage: VkImageUsageFlags) -> Result[Image, Error] {
        create_info := VkImageCreateInfo(
            sType                   = .ImageCreateInfo
            imageType               = ._2d
            format                  = format
            extent                  = VkExtent3D(extent.width, extent.height, 1)
            mipLevels               = 1
            arrayLayers             = 1
            samples                 = ._1Bit
            tiling                  = .Optimal
            usage                   = usage
            sharingMode             = .Exclusive
            initialLayout           = .Undefined
        )
        mut image : VkImage = default
        vk_try(vkCreateImage(device.handle, ^create_info, null, ^mut image))

        memory_requirements := VkMemoryRequirements()
        vkGetImageMemoryRequirements(device.handle, image, ^mut memory_requirements)
        allocation_info := VkMemoryAllocateInfo(
            sType = .MemoryAllocateInfo
            allocationSize = memory_requirements.size
            memoryTypeIndex = device.get_memory_type(memory_requirements.memoryTypeBits, .DeviceLocalBit).unwrap()
        )

        mut memory : VkDeviceMemory = default
        vk_try(vkAllocateMemory(device.handle, ^allocation_info, null, ^mut memory))
        vk_try(vkBindImageMemory(device.handle, image, memory, 0))


        return Ok(Image(image, memory))
    }

    destroy :: (&Self, device: VkDevice) {
        if handle != null then vkDestroyImage(device, handle, null)
        if memory != null then vkFreeMemory(device, memory, null)
    }
}

Buffer :: struct {
    handle : VkBuffer = default
    memory : VkDeviceMemory = default
}

impl Buffer {
    new :: (device: &Device, queue_families: []mut u32, size: u64, usage: VkBufferUsageFlags) -> Result[Buffer, Error] {
        create_info := VkBufferCreateInfo(
            sType = .BufferCreateInfo
            size  = size
            usage = usage
            sharingMode = .Exclusive
            queueFamilyIndexCount = cast queue_families.length
            pQueueFamilyIndices = queue_families.data
        )

        mut buffer : VkBuffer = default
        vk_try(vkCreateBuffer(device.handle, ^create_info, null, ^mut buffer))

        memory_requirements := VkMemoryRequirements()
        vkGetBufferMemoryRequirements(device.handle, buffer, ^mut memory_requirements)
        allocation_info := VkMemoryAllocateInfo(
            sType = .MemoryAllocateInfo
            allocationSize = memory_requirements.size
            memoryTypeIndex = device.get_memory_type(memory_requirements.memoryTypeBits, .HostVisibleBit or .HostCoherentBit).unwrap()
        )

        mut memory : VkDeviceMemory = default
        vk_try(vkAllocateMemory(device.handle, ^allocation_info, null, ^mut memory))
        vk_try(vkBindBufferMemory(device.handle, buffer, memory, 0))

        return Ok(Buffer(buffer, memory))
    }

    destroy :: (&Self, device: VkDevice) {
        if handle != null then vkDestroyBuffer(device, handle, null)
        if memory != null then vkFreeMemory(device, memory, null)
    }
}


#file_scope

vk_try :: (code: Code) #macro {
    result := @insert(code)
    if result != .Success {
        return Err(Error.VulkanApi(result))
    }
}

vk_assert :: (code: Code) #macro {
    result := @insert(code)
    if result != .Success {
        io.formatln("Vulkan API call failed: {}", [result])
        @assert(false)
    }
}

enumerate_instance_extension_properties :: () -> Array[VkExtensionProperties] {
    count : u32 = default
    vkEnumerateInstanceExtensionProperties(null, ^count, null)
    mut result := Array[VkExtensionProperties].new(initial_capacity = cast count)
    result.resize(cast count)
    vkEnumerateInstanceExtensionProperties(null, ^count, result.get_raw_mut())
    return result
}

enumerate_instance_layer_properties :: () -> Array[VkLayerProperties] {
    count : u32 = default
    vkEnumerateInstanceLayerProperties(^count, null)
    mut result := Array[VkLayerProperties].new(initial_capacity = cast count)
    result.resize(cast count)
    vkEnumerateInstanceLayerProperties(^count, result.get_raw_mut())
    return result
}

get_physical_device_queue_family_properties :: (physical_device: VkPhysicalDevice) -> Array[VkQueueFamilyProperties] {
    count : u32 = default
    vkGetPhysicalDeviceQueueFamilyProperties(physical_device, ^count, null)
    mut result := Array[VkQueueFamilyProperties].new(initial_capacity = cast count)
    result.resize(cast count)
    vkGetPhysicalDeviceQueueFamilyProperties(physical_device, ^count, result.get_raw_mut())
    return result
}

enumerate_device_extension_properties :: (physical_device: VkPhysicalDevice) -> Array[VkExtensionProperties] {
    count : u32 = default
    vkEnumerateDeviceExtensionProperties(physical_device, null, ^count, null)
    mut result := Array[VkExtensionProperties].new(initial_capacity = cast count)
    result.resize(cast count)
    vkEnumerateDeviceExtensionProperties(physical_device, null, ^count, result.get_raw_mut())
    return result
}

find_missing_requirements :: (required: []^char8, supported: []$T, name_accessor: fn(&T) -> ^char8) -> Array[String] {
    missing := Array[String].new(required.length)
    for req in required {
        mut found := false
        for prop in supported {
            if string.from_cstring(req) == string.from_cstring(name_accessor(&prop)) {
                found = true
                break
            }
        }
        if !found {
            missing.add(String.from_cstring(req))
        }
    }
    return missing
}

spvc_try :: (code: Code) #macro {
    result := @insert(code)
    if result != .Success {
        message := string.from_cstring(spvc_context_get_last_error_string(@link(context)))
        return Err(Error.SpirvCrossError(fmt.format("{}:{}:{}: {} {}", [code.file, code.line, code.column, result, message])))
    }
}